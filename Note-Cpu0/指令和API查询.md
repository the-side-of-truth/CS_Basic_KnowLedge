# 1 llc #
## 1.1 relocation-model(重定位模式) ##
#### 1. `static`
- **描述**: 静态重定位模型。
- **行为**: 在编译时，所有符号地址都被固定，生成的代码不需要在运行时进行重定位。这种模式通常用于生成独立的可执行文件，适合不需要动态库的环境。
- **使用场景**: 固定地址的嵌入式系统、单片程序、无需动态链接的应用。

#### 2. `pic` (Position-Independent Code)
- **描述**: 位置无关代码模型。
- **行为**: 生成的代码可以在内存中的任何位置运行，而不需要重新编译。编译器通过使用相对地址或全局偏移表（GOT）来引用符号地址。这种模型通常用于生成共享库（`.so` 文件）和动态库。
- **使用场景**: 共享库、插件、动态链接库。

#### 3. `pie` (Position-Independent Executable)
- **描述**: 位置无关可执行文件模型。
- **行为**: 类似于 `pic`，但生成的是可执行文件（通常是 `.exe` 或 `.out` 文件）而不是共享库。这种可执行文件在加载时可以在内存中的任何位置运行，增强了安全性，特别是在启用了地址空间布局随机化（ASLR）的系统上。
- **使用场景**: 安全性要求较高的可执行文件，现代操作系统的可执行文件（如 Linux 和 macOS）。

#### 4. `dynamic-no-pic`
- **描述**: 动态非位置无关代码模型。
- **行为**: 生成的代码是动态的，但不是位置无关的。这意味着符号地址在运行时可能需要被重定位，但生成的代码不是位置无关的。这种模式可以用于动态加载的模块，但通常很少使用。
- **使用场景**: 一些特定的动态加载环境，需要更高效的非位置无关代码。

#### 5. `ropi` (Read-Only Position-Independent)
- **描述**: 只读位置无关模型。
- **行为**: 代码段是位置无关的，但数据段需要固定位置。这种模式通常用于嵌入式系统，代码可以在内存中的任何位置运行，但数据必须在固定地址。
- **使用场景**: 嵌入式系统，特别是那些使用只读存储器（ROM）或闪存的系统。

#### 6. `rwpi` (Read-Write Position-Independent)
- **描述**: 读写位置无关模型。
- **行为**: 数据段是位置无关的，但代码段需要固定位置。这种模式允许数据在内存中任何位置进行操作，而代码段固定。
- **使用场景**: 某些嵌入式系统或安全敏感的应用。

#### 7. `ropi-rwpi`
- **描述**: 结合 `ropi` 和 `rwpi` 的模型。
- **行为**: 代码和数据段都是位置无关的。这种模式在嵌入式系统中很常见，允许整个程序在内存中的任何位置运行。
- **使用场景**: 高度灵活的嵌入式系统，允许整个程序在任意位置运行。

#### 总结
不同的重定位模型在不同的场景下提供了灵活性和效率的平衡。通常，`static` 用于静态编译、`pic` 用于共享库、`pie` 用于可执行文件，而其他模型如 `ropi` 和 `rwpi` 则适用于特定的嵌入式环境。


## 1.3 ##
### 调度文件InstrItinClass类 ###
InstrItinClass 是 LLVM 后端中用于描述处理器指令流水线行为的重要类。它为每条指令定义了在处理器不同功能单元中执行的时间表，帮助 LLVM 在指令调度阶段优化指令的执行顺序。通过在 .td 文件中定义 InstrItinClass，开发者可以精确地描述处理器架构的行为，从而生成高效的目标代码。