本文档主要是记录cpu0后端开发遇到的基础知识，与章节对应，分开写会整洁些。

# 0 教程之外的LLVM基础知识

## 0.1 后端涉及的数据结构

- LLVM-IR
- Machine Instruction (MI)
- Machine Code (MC Inst)

这些结构的区别在哪里？

### (1)LLVM-IR

目标机模型：

- 寄存器：无限寄存器
- 指令集：目标无关的,文本的指令
- 调用规范：作为函数的一种属性存在，并没有特殊之处
- 除此之外还有一大堆属性

内存模型：

- 一个文件是一个module
- 一个moudle由一系列全局量组成,包括全局变量和函数
- 全局变量和函数都具有应对外部访问的属性，包括链接属性和可见性
- 函数由一系列具有控制流关系Basic Block组成，构成控制流图
- 一个Basic Block由一串指令构成，结尾一定是跳转类指令
- SSA值：静态单赋值，可以查询由谁定义和被谁使用，可在一个基本块内构成DAG

### (2)Machine Instrction

目标机模型：

- 寄存器：有两个阶段，寄存器分配前是无限的，分配后是有限的
- 不确定是不是TargetMachine

内存模型：分两个阶段来看，以寄存器分配(RA)为界限。RA之前与IR对应的内存模型几乎一样。RA之后就不再是SSA形式了。所有指令都变成了操作码+操作数的形式。

### (3)MC Inst

是LLVM中最底层的存在

指令格式：指令码+操作数

操作数类型：立即数+寄存器引用+符号（?）


# 1 注册一个后端 

## 1.3 注册目标机 
### 1.3.2 修改文件 
#### (1)Triple 
在编译器和工具链中，"Triple" 是一个字符串，通常由三个部分组成，用于描述目标平台的架构、供应商、和操作系统,它的全名是 "Target Triple"。**顾名思义，Triple是用来描述目标的，只是交叉编译的一部分，千万不要以为Triple就是交叉编译的全部。**

典型的 Triple 字符串由以下三个主要部分组成：

- 架构（Architecture）：指处理器架构类型，如 x86_64、arm,、aarch64、mips 等。
- 供应商（Vendor）：指定处理器或系统的供应商，如 pc、apple、unknown 等。它可能是空的或使用 unknown 表示。
- 操作系统（Operating System）：指定目标操作系统，如 linux、windows、darwin (macOS) 等。

但有时也会包含其他信息，通常格式如下：

	<arch>-<vendor>-<sys>-<abi>，下面放一个例子:
	arch：目标架构
	vecdor: 供应商
	sys: 目标操作系统
	abi: 应用程序二进制接口
	x86_64-pc-linux-gnu: 64位x86架构，PC供应商，Linux操作系统，GNU ABI。

到这里又不得不补充一些**交叉编译**的常见概念

- 主机（Host）：编写程序的平台，编译器所在的平台，即执行编译操作的平台。
- 目标（Target）：最终生成的二进制文件将运行的平台。
- 构建（Build）：编译器自身运行的平台。这通常和主机一致，除非在做更复杂的编译环境，如构建一个新的交叉编译器。

### (2)调度文件 ###
#### 一些指令 ####
CLO（Count Leading Ones）和 CLZ（Count Leading Zeros）是用于计算二进制数中前导位数量的指令。

#### 对调度的思考 ####
首先要思考一条指令是怎么执行的，会用到哪些东西。不同指令的执行会用到不同的功能单元，这些单元是有限的，所以如何合理地调度资源的使用非常关键。下面是一个简单的分类(根据CpuScheduel.td)

- Load,Stroe: 存取类指令，MAR,MDR,寻址(ALU)

# 2 后端结构 #
## 2.1 目标机器架构 ##
### 2.1.1 目标属性 ###
#### (1) 数据布局 ####
描述数据在内存中的布局，理论上拿到这个信息后就可以知道任何一种类型的数据在内存中如何存放了。

严谨定义：数据布局（Data Layout）描述了目标平台的内存模型，即如何在内存中排列数据。它通常在编译器或程序生成中用于确定数据的对齐方式、数据类型的大小、以及*函数调用约定*等。（？？？怎么会出现函数调用约定）

示例：E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64

#### (2) 重定位模式 ####
重定位模式（Relocation Model）是在编译器生成目标代码时指定如何处理程序中的符号地址的一种机制。重定位模型决定了程序在编译和链接后如何加载到内存中，以及在加载时是否需要调整或修改符号的地址。它在编译生成可执行文件或共享库时非常重要，因为不同的重定位模型适合不同的应用场景和平台要求。

**静态重定位模型（Static Relocation Model）:**

在这种模式下，所有符号地址在编译和链接时都被固定下来，生成的可执行文件在加载时不需要进一步修改地址。这种模型生成的代码非常简单，执行效率高，但不能用于需要动态加载或共享库的场景。
在 LLVM 中，这种模式通常通过 -relocation-model=static 指定。

**动态重定位模型（Dynamic Relocation Model 或 Position-Independent Code, PIC）:**

动态重定位模型允许生成的代码在内存中任何位置加载和执行。这通常用于生成共享库（Shared Libraries）或动态加载的可执行文件。符号地址在运行时会通过重定位表进行调整。
在 LLVM 中，通过 -relocation-model=pic 或 -fPIC 选项来启用位置无关代码的生成。

**动态无位置独立代码模型（Dynamic No Position-Independent Code, Dynamic-No-PIC）:**

类似于动态重定位模型，但不生成位置无关代码，而是依赖操作系统的动态链接器在加载时进行调整。这种模型用于需要动态重定位但又不需要或不能使用 PIC 的场景。
在 LLVM 中，可以通过 -relocation-model=dynamic-no-pic 指定。

**自定义或局部重定位模型（Local Dynamic, Local-Exec, etc.）:**

这些模型为更细粒度的重定位策略，通常用于优化访问全局变量或函数指针的代码路径。它们主要用于特定的体系结构或性能优化。更详细的可以看看llc的relocation-model(重定位模式)选项

#### (3)ABI ####
ABI，全称为 Application Binary Interface（应用二进制接口），是一套用于定义软件在运行时如何与操作系统、硬件或其他软件组件交互的规则和约定。与 API（应用编程接口）不同，API 定义了源码级别的接口，而 ABI 定义的是二进制级别的接口。

ABI 是一组规则，确保在操作系统、硬件、编译器之间正确传递数据和调用函数。它是编译器、链接器、操作系统、以及应用程序在运行时协作的重要基础。ABI是在一个确定的体系结构上定义的。

##### 函数调用约定（Calling Conventions) #####

定义函数参数如何传递（通过寄存器或栈），函数返回值如何返回，调用者和被调用者如何管理栈（如谁负责清理栈）。

###(4) ELF文件格式 ####
待补充